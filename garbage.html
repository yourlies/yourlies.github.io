<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <link href="//fonts.googleapis.com/css?family=Montserrat|Roboto:400,400italic,600|Roboto+Mono" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="./app/common.css" type="text/css" />
    <link rel="stylesheet" href="./app/new_post.css" type="text/css" />
  </head>
  <body>
    <div id="wrapper">
      <!-- pc header -->
      <div class="header mobile-hidden">
        <div class="placeholder"></div>
        <div class="title">
          <h1>v8垃圾回收机制</h1>
        </div>
        <div class="subtitle">
          <p class="author">lies</p>
          <p class="links placeholder">
            <a href="javascript:;" target="_blank"><img src="./app/twitter.png"/></a>
            <a href="javascript:;" target="_blank"><img src="./app/github.png"/></a>
            <a href="javascript:;" target="_blank"><img src="./app/feed.png"/></a>
          </p>
        </div>
      </div>
      <!-- mobile header -->
      <div class="header pc-hidden">
        <a href="javascript:;">v8垃圾回收机制</a>
      </div>
      <p class="links pc-hidden">
        <a href="javascript:;" class="author">lies</a>
        <a href="javascript:;" target="_blank"><img src="./app/twitter.png"/></a>
        <a href="javascript:;" target="_blank"><img src="./app/github.png"/></a>
        <a href="javascript:;" target="_blank"><img src="./app/feed.png"/></a>
      </p>
      <div class="main post">
        <div class="title">
          <h2>垃圾回收?</h2>
          <h4>// what & why?</h4>
        </div>
        <div class="block">
          <p>
            事实上，定义变量，实际上是在内存开辟一块新的区域，来储存你的内容，也就是你变量中所有的数据都是储存在内存中的，那么问题就来了，假如毫无节制的开辟新的区域来储存内容，内存迟早会被耗尽，其中绝大部分内存是被一些无意义的变量给消耗掉了
          </p>
          <p>因此如何找出并消灭掉这些赖在内存里不走，又没有意义的变量就显的刻不容缓，一般现代高等语言在设计之初就会考虑到设计一个通用的垃圾回收机制，使得开发人员（搬砖码农）不需要去关心这些内容，从而能极大的提高开发效率</p>
          <p>同样的，一般来说在浏览器中，哪怕你写出来一些无法被垃圾回收机制回收的变量，也不一定会出问题，因为浏览器一刷新，在现代操作系统中，你的进程所分配的内存会被内存管理器释放掉，但是假如用nodejs作为服务端开发的话，那内存回收就是必须得关心的了，因为你没办法动不动就重启服务</p>
        </div>
        <div class="title">
          <h2>垃圾回收！</h2>
          <h4>// kinds</h4>
        </div>
        <div class="block">
          <p>实际上垃圾回收的机制有很多种，包括但不限于标记清除，引用计数</p>
          <p>C#、Java、JavaScript都有自动垃圾回收机制，但c++和c就没有垃圾回收机制，也许是因为垃圾回收机制必须由一种平台来实现。在JavaScript中，JavaScript的执行环境会负责管理代码执行过程中使用的内存</p>
          <ul>
            <li>标记清除：分为标记和清除两个阶段，首先标记出所有的需要回收的对象，在标记完成以后统一回收所有被标记的对象。</li>
            <li>引用计数：对象在创建时保存一个自身被引用的计数，初始值为1。每次被新的变量引用，该值加1。相反，则减去1。当该值等于0时，占用空间被系统回收。</li>
          </ul>
        </div>
        <div class="title">
          <h2>v8垃圾回收</h2>
          <h4>// v8 garbage collector</h4>
        </div>
        <div class="block">
          <p>
            v8引擎是一个JavaScript的运行时，v8的垃圾回收机制为，分代回收机制，该机制又基于世代假说，有两个特点
          </p>
          <ul>
            <li>1. 大部分新生对象都倾向于早死</li>
            <li>2. 不死的对象大部分都会活的更久</li>
          </ul>
          <p>基于此，现代垃圾回收算法根据对象的存活时间将内存进行了分代，并对不同分代的内存采用不同的高效算法进行垃圾回收</p>
        </div>
        <div class="title">
          <h2>v8的堆构成</h2>
        </div>
        <div class="block">
          <ul>
            <li>1. 新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁</li>
            <li>2. 老生代指针区：属于老生代，这里包含了大多数可能存在指向其他对象的指针的对象，大多数从新生代晋升的对象会被移动到这里</li>
            <li>3. 老生代数据区：属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针</li>
            <li>4. 大对象区：这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象</li>
            <li>5. 代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区</li>
            <li>6. Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单</li>
          </ul>
          <p>每个区域都是由一组内存页构成，内存页是V8申请内存的最小单位，除了大对象区的内存页较大以外，其他区的内存页都是1MB大小，而且按照1MB对 齐。内存页除了存储的对象，还有一个包含元数据和标识信息的页头，以及一个用于标记哪些对象是活跃对象的位图区。另外每个内存页还有一个单独分配在另外内 存区的槽缓冲区，里面放着一组对象，这些对象可能指向其他存储在该页的对象。垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收</p>
        </div>
        <div class="title">
          <h2>一次完整的垃圾回收过程</h2>
        </div>
        <div class="block">
          <ul>
            <li>1. 第一步，假设现在定义了一个新鲜的变量</li>
            <li>2. <b>由于执行垃圾回收的时候会回收变量，如果此时变量对象的引用还在变化，那这个算法几乎无法进行，为了防止这个情况的出现，需要先暂停应用逻辑，称之为stop-the-world</b>，简单粗暴，不过标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行</li>
          </ul>
        </div>
      </div>
    </div>
    <canvas id="canv"></canvas>
    <script>
      var $process = {}
    </script>
    <script src="https://yourlies.github.io/weather/drop.js"></script>
    <script src="https://yourlies.github.io/weather/weather.js"></script>
    <script>
      ;(function() {
        var watchers = []
        var canv = document.getElementById('canv')
        var ctx = canv.getContext('2d')
        var width = window.innerWidth
        var height = window.innerHeight
        var drop = new $process.Drop({ canv: canv, ctx: ctx })
        var recycle = function(e) {
          drop.watcher({ x: e.x, y: e.y, forward: 1 })
        }
        var rainy = new $process.Rainy({ recycle: recycle, ctx: ctx })
        watchers.push(drop)
        watchers.push(rainy)
        var raf = function() {
          ctx.clearRect(0, 0, width, height)
          watchers.forEach(function(e) {
            e.updater()
          })
          requestAnimationFrame(raf)
        }
        requestAnimationFrame(raf)
        window.onmousedown = function(e) {
          drop.watcher({ x: e.clientX, y: e.clientY })
        }
      })()
    </script>
  </body>
</html>
